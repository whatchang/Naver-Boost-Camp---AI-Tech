# Day 1 ( Python basic for AI 1 ~ 2강 / AI Math 1 ~ 4 강)

## 목차 

1. [강의 내용 정리](#1-강의-내용-정리)
2. [과제 수행 과정 / 결과물 정리](#2-과제-수행-과정--결과물-정리)
3. [피어세션 정리](#3-피어세션-정리)
4. [학습 회고](#4-학습-회고)



----

### 1. 강의 내용 정리

* Python basic for AI 1 ~ 2강
    * 1-1강 : Basic computer class for newvies
        * OS(Operating Sysmte) - 하드웨어와 소프트웨어의 중간 역할을 해준다. <br>
        ∴ 프로그램(소프트웨어)은 OS에 의존적이다. 

        * 파일 시스템 - OS에서 파일을 저장하는 트리구소 저장 체계<br>
        &nbsp; - &nbsp;디렉토리 <br>
        &nbsp;&nbsp;&nbsp;&nbsp; ‣ &nbsp; 폴더 또는 디렉토리로 불림<br>
        &nbsp;&nbsp;&nbsp;&nbsp; ‣ &nbsp; 파일과 다른 디렉토리를 포함할 수 있다.<br><br>
        &nbsp; - &nbsp;파일<br>
        &nbsp;&nbsp;&nbsp;&nbsp; ‣ &nbsp; 컴퓨터에서 정보를 저장하는 논리적인 단위이며 실행, 쓰기, 읽기 등을 수행<br>
        &nbsp;&nbsp;&nbsp;&nbsp; ‣ &nbsp; 파일은 파일명과 확장자로 구분할 수 있다.<br><br>
        &nbsp; - &nbsp;경로<br>
        &nbsp;&nbsp;&nbsp;&nbsp; ‣ &nbsp; 절대경로 : 루트 디렉토리(windos에서는 C드라이브)부터 해당 파일위치까지 경로<br>
        &nbsp;&nbsp;&nbsp;&nbsp; ‣ &nbsp; 상대경로 : 현재 있는 디렉토리부터 타깃 파일까지의 경로<br>
        &nbsp;&nbsp;&nbsp;&nbsp;☆&nbsp; . 은 현재 디렉토리, .. 은 이전 디렉토리를 의미한다.

        * 터미널 - 마우스가 아닌 키보드로 명령을 입력을 받아 명령을 수행 (CLI 환경) <-> GUI와 반대<br>
        ☆ 어원 : 과거 하드웨어가 좋지 못했을때 중앙에 서버나 컴퓨터를 놓고 여러 사람이 접근하여 사용하는 방식에서 유래 -> 명령어를 중앙 장치까지 보내는 창이 터미널과 같은 역할을 해서 유래가 되었다고 한다.(maybe?)<br><br>
        ⁃ 기본 명령어
    
        |윈도우 명령어|shell 명령어|설명|
        |:---:|:---:|:---:|
        |CD|CD|현재 디렉터리 이름을 보여주거나 바꿔준다. change directory의 약자|
        |CLS|clear|터미널 화면에 표시된 것을 모두 지워준다. clear screen의 약자|
        |COPY|cp|하나 이상의 파일을 다른 위치로 복사해준다. copy|
        |DEL|rm|하나 이상의 파일을 지워준다. delete와 remove의 약자|
        |DIR|ls|디렉토리에 있는 파일과 하위 디렉토리 목록을 보여준다. directory, list의 약자|

        <br>

    * 1-2강 : 파이썬 개요
        - 플랫폼 독립적 언어
        - 인터프리터 언어(프로그램 실행시 기계어로 바꿔줌, os에 상관없이 실행 가능) <-> 컴파일 언어(실행전 어셈과 기계어로 번역해줌, os에 따라 실행이 안 될 수도 있음)
        - 객체 지향
        - 동적 타이핑 언어 - 프로그램 실행시 데이터 타입을 정하는 방식
        - 다양한 라이브러리가 있다.
        
        &nbsp;&nbsp;☆ 파이썬의 유래 : 몬티 파이썬이라는 코메디 그룹에서 이름이 유래되었다. 그리고 여기서 파이썬은 그리스 신화속 괴물 뱀을 말한다.
        <br>

    * 1-3강 : 파이썬 코딩 환경설정<br>
    <t> 생략~~~

    * 2-1강 : Variables
        * 변수 : 값을 저장하기 위한 메모리 공간 -> 선언되는 순간 메모리 특정영역에 물리적인 공간이 할당된다.<br>
        &nbsp;  ☆ 변수 이름 규칙<br> 
        &nbsp;&nbsp;&nbsp;&nbsp;      1. 알파벳, 숫자, 언더스코어(_)로 선언 가능<br>
        &nbsp;&nbsp;&nbsp;&nbsp;      2. 변수명은 의미있는 단어로 표기<br>
        &nbsp;&nbsp;&nbsp;&nbsp;      3. 변수명은 대소문자가 구분됨<br>
        &nbsp;&nbsp;&nbsp;&nbsp;      4. 변수명에 예약어 사용 불가능<br>
        * 기본 자료형 : integer, float, string, boolean <br>
        &nbsp;  ☆ short, long, double등의 자료형은 없는것 같다.<br>
        &nbsp;  ☆ Dynamic typing이라서 실행시점에 데이터 타입이 결정된다.
        * 연산자(operator)는 +, -, *, /, % 등과 같은 것을 말하며 피연산자(operand)는 연산이 되어지는 대상(3, 1, 등과 같은 숫자)이다.<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Q. 10.3과 10.7을 int로 형변환을 한 후 더하면 결과는?<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A. 20<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp; ☆ 컴퓨터의 반올림 오차<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 컴퓨터는 모든 값을 이진수로 변환하여 메모리에 저장을 한다. 이때 단순한 실수도 이진수로 변홤하면 무한소수가 된다. 그래서 38.8이라는 소수가 38.799999999... 가 나올 수 있고 반올림을 하여 이러한 현상을 없애준다. 반올림오차는 충분히 작기 때문에 일반적으로는 문제가 되지 않는다.
        * list : 시퀀스 자료형, 여러 데이터들의 집합 -> C에서 array와 linked-list역할과 비슷함.<br>
        &nbsp; - 특징<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 1. 인덱싱<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 2. 슬라이싱<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 3. 연산<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 4. 추가 삭제<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 5. 주소를 참조하는 저장방식<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 6. 패킹과 언패킹<br><br>
        &nbsp;  ☆ 일차원 리스트 b가 있을때 a = b[:]를 하면 b의 값들이 복사되어 a에 저장이 된다. 그래서 a의 원소를 바꾸더라도 b에 영향을 주지 않는다. 그러나 이차원인 b에 대해서 a = b[:]을 했을때 a[0][1]의 원소값을 바꾸면 b도 바뀌는가? 그렇다면 어떻게 복사를 해야지 값이 안 바뀌는가? 단, copy.deepcopy함수를 사용하지 마시오.<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp; A. 내 생각 : 리스트 저장방식은 주소를 저장하는 방식이기 때문에 이차원 리스트의 경우 각 일차원 리스트의 주소를 담고 있을거라고 생각됨. 그러므로 일차원 리스트의 주소가 아닌 그 주소가 가지고 있는 값들을 복사해줘야 함. a = [[x for x in y] for y in b] 이렇게 하면 되지 않을까 싶음.<br>


    * 2-2강 : Function and Console I/O
        * 함수 : 어떤 일을 수행하는 코드의 덩어리<br>
        &nbsp; - 특징<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 1. 코드를 논리적인 단위로 분리해줄 수 있다.<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 2. 캡슐화를 통해서 정보 은닉 및 인터페이스만 알면 타인이 내부를 알 필요 없이 사용할 수 있음. (정확하게는 클래스가 캡슐화고 함수는 캡슐화가 아닌걸로 알고 있는데... 음... ?)<br>
        &nbsp; - 수행 순서<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 1. 메인 프로그램 수행.<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 2. 함수 호출.<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 3. 함수 수행.<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 4. 이전에 수행했던 메이 프로그램 그 후부터 다시 수행<br>
        &nbsp;&nbsp;&nbsp;&nbsp; ☆ 이때 선언한 함수는 메인 프로그램, 즉 main code 이전에 선언 및 정의 되어야 한다.<br><br>
        &nbsp; - parameter : 함수의 입력 값이 들어오는 인터페이스<br>
        &nbsp; - argument : 함수 입력값으로 주어지는 값<br><br>
        * input() : 콘솔창에서 문자열 형식으로 값을 입력 받아오는 함수
        * print() : 모니터에 문자열, 정수, 실수 등을 출력하는 함수<br>
        &nbsp; - print format<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 1. % format<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 2. str.format()<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 3. f-string : 현제 가장 많이 사용되는 방식으로 f'아무거나 {name}'으로 사용된다. 이때 {name:20}은 padding을 20을 주고 왼쪽부터 문자열을 채우는 방식이고 {name::>20} 반대이다. 그리고 {name:*^20}은 20패딩을 주고 가운데 정렬후 빈 공간을 *로 채운다는 의미이다.<br>


    * 2-3강 : Conditionals and Loops
        * 조건문 : 조건에 따라 특정한 동작을 하게하는 명령문
        &nbsp; - if, else, eilf 등의 예약어를 사용하여 조건문을 처리한다.
        &nbsp;&nbsp;&nbsp;&nbsp; ☆ 조건 판단에서 사용되는 비교연산자 중 is, not is는 다른 비교연산자들과 다르게 값을 통해서 검사를 하는 방식이 아닌 메모리 주소를 통해서 비교하는 방식이다.
        * 반복문 : 정해진 동작을 반복적으로 수행하게 하는 명령문
        &nbsp; - for, while, break, continue 등의 예약어를 사용한다.<br>
        &nbsp; ☆ 생소했던 문법 for ~ else 혹은 while ~ else : loop가 끝나면 else를 수행하는 명령문
        * 가변적인 중첩 반복문 
        &nbsp; - 사용자의 입력에 따라 가변적으로 반복되는 반복문
        * 디버깅<br>
        &nbsp; - 코드의 오류를 발견 및 수정하는 과정
        &nbsp; - 문법적 에러와 논리적 에러가 있다.<br>
        ☆ 파이썬 import 할 때 쓸데없는 코드가 실행하는 것을 방지하기 위해서는 if __ name __ == "__ main __" : 을 넣어줘야 한다.<br>

    * 2-4강 : String and advanced functions concept
        * 문자열 : 시퀀스 자료형으로 문자형 data를 메모리에 저장
        * 문자열 특징 <br>
        &nbsp; - 인덱싱<br>
        &nbsp; - 슬라이싱<br>
        &nbsp; - in연산자 : 포함되어 있는지 여부 체크<br><br>

        |함수명|기능|
        |:---:|:---:|
        |len(a)|문자열의 문자 개수를 반환|
        |a.upper()|대문자로 변환|
        |a.lower()|소문자로 변환| 
        |a.capitalize()|첫 문자를 대문자로 변환|
        |a.titile()|제목형태로 변환 띄워쓰기 후 첫 글자만 대문자|
        |a.count('abc')|문자열 a에 'abc'가 들어간 횟수 반환|
        |a.find('abc')<br>a.rfind('abc')|문자열 a에 'abc'가 들어간 위치(오프셋) 반환|
        |a.startswith('ab'c)|문자열 a는 'abc'로 시작하는 문자열여부 반환|
        |a.endswith('abc')|문자열 a는 'abc'로 끝나는 문자열여부 반환|
        |a.strip()|좌우 공백을 없앰|
        |a.rstrip()|오른쪽 공백을 없앰| 
        |a.lstrip()|왼쪽 공백을 없앰|
        |a.split()|공백을 기준으로 나눠 리스트로 반환|
        |a.split('abc')|abc를 기준으로 나눠 리스트로 반환|
        |a.isdigit()|문자열이 숫자인지 여부 반환|
        |a.islower()|문자열이 소문자인지 여부 반환|
        |a.isupper()|문자열이 대문자인지 여부 반환|
        <br><br>
        * 함수 호출 방식 
        &nbsp; 1. 값에 의한 호출(call by value) : 값만 넘김, 파라미터로 받은 값을 변경하더라고 인자는 영향을 받지 않음<br>
        &nbsp; 2. 참조의 의한 호출(call by reference) : 메모리 주소를 넘김, 파라미터로 받은 값을 변경하면 인자에 영향을 줌<br>
        &nbsp; 3. 객체 참조에 의한 호출(call by object reference) : 객체의 주소가 함수로 전달되는 방식
        * 변수의 범위
        &nbsp; - 지역변수 : 함수내에서만 사용 가능<br>
        &nbsp; - 전역변수 : 프로그램 전체에서 사용 가능<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Q. 지역변수와 전역변수의 이름이 같다면 어떤 값에 영향이 있을까?<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A. 지역변수가 영향이 있음(사용됨).
        * 재귀함수 : 자기자신을 호출하는 함수. 만약 종료조건을 주지 않는다면 무한히 반복된다. 그러므로 종료조건을 추가해 줘야 한다.
        * function type hints 
                
                def 함수명(변수명 : 변수타입) -> 리턴타입:
                    함수 내용
            위와 같은 형식으로 사용되며 함수 사용시 data type을 예측할 수 있어서 용이함.
            <br>
            &nbsp; - 장점<br>
            &nbsp;&nbsp;&nbsp;&nbsp; 1. 사용자에게 인터페이스를 명확히 알려줄 수 있다.<br>
            &nbsp;&nbsp;&nbsp;&nbsp; 2. 함수의 문서화시 파라미터에 대한 정보를 명확히 알 수 있다.<br>
            &nbsp;&nbsp;&nbsp;&nbsp; 3. mypy 또는 IDE, linter 등을 통해 코드의 발생 가능한 오류를 사전에 인지할 수 있다.<br>
            &nbsp;&nbsp;&nbsp;&nbsp; 4. 시스템 안정성을 확보할 수 있다.

        * docstring : 파이썬 함수에 대한 상세내용을 사전에 작성 -> 함수 사용자가 함수를 사용하기 편함
        * 함수 작성 가이드 라인<br>
        &nbsp; - 간결하게 작성<br>
        &nbsp; - 함수 이름에 함수의 역할 및 의도가 명확해야 된다.<br>
        &nbsp; - 응집성을 높여야 한다.<br>
        &nbsp; - 인자로 받은 값에 영향을 주지 않는 방향으로 사용<br>
        * 코드를 작성하기 위한 규칙 : 코딩 컨벤션<br>
        &nbsp; - 일관성 있게 작성 => 일반적으로 파이썬에서는 들여쓰기는 4space로 사용하지만 tab을 사용해도 상관없음. But 이 둘을 혼합하면 일관성을 해침.<br>
        &nbsp; - flake8 모듈을 통해서 코딩 컨벤션을 잘 준수했는지 알 수 있다.<br>
        &nbsp; - black 모듈을 통해서 자동으로 pep8 코딩 컨벤션을 준수하도록 수정해 줄 수 있다.

        <br><br>
* AI Math 1 ~ 4강
    * 1강 : 벡터
        * 백터 : 공간에서 한 점을 나태내며 이때 원점으로부터 상대적인 위치로 표시한다.<br>
        &nbsp;    - 벡터끼리 같은 모양을 가져야지 덧셈과 뺄셈등의 연산을 할 수 있다.<br>
        &nbsp;  - 벡터의 성분곱이란 모양이 같은 벡터끼리 같은 위치의 원소(성분)들을 곱하는 것을 의미한다.<br>
        &nbsp;  - 벡터의 덧셈과 뺄셈 모두 다른 벡터로부터 상대적 위치이동이다. 

        * 벡터의 노름 : 원점에서부터의 거리를 말한다.<br>
        &nbsp;  - L1 : 각 성분의 변화량의 절대값을 더한 값<br>
        &nbsp;  - L2 : 유클리드 거리

        * 두 벡터 사이의 각도 구하기 (L2 노름만 가능하다)<br>
        &nbsp;  - 벡터 x, y가 있을때 사이의 각도 𝜃를 구하기 위해서 제2 코사인 법칙을 이용하면 된다.<br>
        &nbsp;  - 제2 코사인 법칙에서 분자는 내적을 통해서 쉽게 구할 수 있다.

    * 2강 : 행렬
        * 행렬 : 벡터를 원소로 가지는 2차원 배열을 의미한다. <br>
        &nbsp;  - 행렬은 행(row)와 열(column)으로 구성이 된다.<br>
        &nbsp;  - 전치행령은 행과 열의 인덱스를 바꾼 행렬을 의미한다.
        * 행렬 이해하는 방법 <br>
        &nbsp;  1. 공간상의 점들을 모임이라고 생각하기<br>
        &nbsp;  2. 행렬곱을 통해 벡터를 다른 차원의 공간으로 보내주는 연산자라고 생각하기
        * 행렬 연산
        &nbsp;  - 행렬의 덧셈, 뺄셈, 성분곱 등 벡터와 동일하게 같은 모양을 가지면 할 수 있다.<br>
        &nbsp;  - 스칼라곱도 벡터와 똑같은 방식으로 된다.<br>
        &nbsp;  - 행렬 곱셈 : 행렬 X, Y를 XY와 같이 행렬 곱셈을 한다면 X의 i번째 행벡터와 Y의 j번째 열벡터 사이의 내적을 성분으로 가지는 행렬을 계산하면 된다. 이때 행렬 곱셈을 하기 위해서는 X, Y의 크기가 n * m, m * k 와 같이 X의 행벡터의 사이즈와 Y의 열벡터 사이즈가 같아야 한다.<br>
        &nbsp;  ☆ numpy에서는 행렬곱을 할때 @기호를 이용하여 다음과 같이 사용한다. ex) X @ Y<br>
        &nbsp;  - 수학에서의 행렬의 내적과 numpy에서의 내적은 다름으로 주의해서 사용해야 한다.
        * 역행렬 : 행렬 X가 있을대 역행렬을 행렬 곰셈을 하게 된다면 항등행렬이 나온다. 이와 같이 역행렬을 나오기 위한 조건은 determinant가 0이 아니여야 한다.
        * 유사역행렬(무어-펜로즈) : 역행렬을 구할 수 없을때 사용하는 방법이다. 이때 행과 열의 크기에 따라 공식이 다름으로 주의하자.

    * 3강 : 경사하강법(순한맛)
        * 미분 : 변수의 움직임에 따른 함수값의 변화를 측정하기 위한 도구이다. 접선의 기울기를 구하기 위해서 미분을 사용한다.<br>
        &nbsp;  - 미분에서 구한 접선의 기울기를 통해서 어떤 방향으로 움직였을때 함수값이 증가/감소하는지 알 수 있다.<br>
        &nbsp;  ☆ 접선의 기울기가 양수라면 오른쪽으로 이동(x값 증가)하면 함수값 증가(y값 증가), 왼쪽으로 이동시(x값 감소) 함수값 감소(y값 감소). 접선의 기울기가 음수라면 반대.
        * 경사상승법 : 극대값의 위치를 구하는 방법
        * 경사하강법 : 극소값의 위치를 구하는 방법<br>
        &nbsp;  ☆ 경사상승법, 경사하강법 등은 접선의 기울기를 이용하며 극값에 도달하였을때 멈추게 된다.
        * 편미분 : 입력이 다변수인 경우에 사용하는 미분으로 특정 방향(변수)를 기준으로 미분을 한다. 예를 들어서 F라는 함수가 있고 x,y,z 등의 여러 변수가 있을때 x에 대해서 편미분을 한다면 x만 변수 취급을 해주고 다른 변수들은 상수로 생각하고 미분을 해주면 된다.<br>
        * 그레디언트(gradient) 벡터란 각 변수 별로 편미분을 계산한 것으로 경사하강법 혹은 경사상승법에 사용할 수 있다.

    * 4강 : 경사하강법(매운맛)
        * 선형회귀의 목적식 ∥y − Xβ∥2 이고 이를 최소화하는 β를 찾아야 한다.<br>
        &nbsp;  ∴ 실제 y값과 목적식에서 구한 y-hat의 차이를 최소화하는 그레디언트 벡터를 구해야 한다.
        * 경사하강법의 한계<br>
        &nbsp;  - 경사하강법은 적절한 학습률과 학습횟수를 선택해야 수렴이 보장된다.<br>
        &nbsp;  - 또한 비선형회귀 문제의 경우 목적식이 볼록하지 않을 수 있으므로(구불구불, 울퉁불퉁한 형태) 수렴이 항상 보장되지 않습니다.<br>
        &nbsp;  ☆이것을 보완하기 위해서 나온 방식이 활률적 경사하강법(stochastic gradient decent)입니다.
        * 확률적 경사하강법이란?<br>
        &nbsp;  - 모든 데이터를 사용해서 그레디언트 벡터를 업데이트를 하는 것이 아닌 일부만을 활용하여 갱신하는 방법입니다.<br>
        &nbsp;  ☆이 방식을 통해서 볼록이 아닌(non-convex) 목적식에서 최적화를 할 수 있습니다.<br>
        &nbsp;  ☆미니배치를 사용하여 SGD보다 더 효율적으로 학습시킬 수 있습니다.<br>

### 2. 과제 수행 과정 / 결과물 정리
<br>

#### 프로그래밍 과제는 원하는 메소드를 구글을 통해서 찾고 해당 메소드를 이용하여 과제를 해결하였다. 수학같은 경우는 그전에 부스트코스에서 퀴즈내용과 같아 어렵지 않게 풀었다. 그때 당시 찍었던 문제를 이번에 직접 계산해서 풀었는데 매우 뿌듯하였다 ㅎㅎ😤 

<br>

### 3. 피어세션 정리

* 팀명 : Pick Me
* 모더레이터 & 서기
    * 모더레이터 할 일
        *  강의 리뷰
        * 질문 취합
        * 멘토 미팅 설정
        * 그 외 이슈 처리
    * 서기 할 일
        * 회의록 작성 및 업로드, 금일 해결하지 않은 문제 취합
* 그라운드 룰
    * 호칭은 ‘~님’
    * 상호존중
    * 쉬운 질문이라도 무시 않기
    * 충분히 고민한 후 질문하기
    * 부득이한 사정으로 인한 피어세션 불참시 당일 19시 이전에 사유 공지하기
    * 모더레이터 불참 시 익일 예정된 모더레이터로 대체
    * 개익 학습 정리에 대한 활발한 상호 피드백 지향
    * 개인 스터디 노트 공유
* 협업 툴
    * 회의록 작성 : GoogleDOc
    * 코드 리뷰 : Github, Colab
    * 소통 : Slack, KakaoTalk, Zoom
* 피어세션 진행 방식
    * 질의응답
    * 개인 스터디 노트 공유 및 코드 리뷰
    * 상호 피드백

* 이번 피어세셕에 나왔던 질문 - 유사역행렬(무어-펜로즈) 유도 공식에 대한 질문


### 4. 학습 회고

#### 강의를 듣고 정리하는데 다른 캠퍼분들보다 많이 느린것 같아서 공부 방식을 바꿔야 할 것 같다는 생각이 들었다. 그리고 같은 조 캠퍼분들에 비해 내가 실력이 부족한 것 같아서 포기하지 않고 뒤따라가는 것을 목표로 공부해야겠다. 천천히 가도 좋으니까 포기하지 않고 잘 따라가야겠다. 화이팅~~~👍


